"""
analysis_iq_sq.py

Compute averaged I(q), S(q), and g(r) from the structural configurations
generated by hoc_structural_model.py.

Features:
- Single unified progress bar for all configs × q-points.
- Exact disc scattering amplitude (orientation-dependent cylinder form factor).
- S(q) from center-of-mass positions only.
- g(r) radial distribution function from center-of-mass distances.
- Final figure with 3 subplots: I(q), S(q), g(r).
- CSV output with I(q) and S(q).
"""

import os
import glob
import math
import numpy as np
import matplotlib.pyplot as plt

from scipy.special import j1  # Bessel J1
from tqdm import tqdm         # unified progress bar + safe logging


# ============================================================
# CONFIGURATION
# ============================================================

DATA_DIR = "hoc_output_prob0.8_random_n50000"
FILE_PATTERN = "hoc_structure_coords_*.csv"

# Geometry of disc (must match hoc_structural_model.py)
RADIUS = 25.0       # nm
THICKNESS = 1.0     # nm
DELTA_RHO = 1.0     # contrast (overall scale factor)

# q-grid
Q_MIN = 0.005
Q_MAX = 5
N_Q = 100
LOG_Q = True

# Directions for orientational average
N_Q_DIRECTIONS = 24
RNG_SEED = 12345

# g(r) calculation
GR_RMAX = 300.0       # nm
GR_NBINS = 60

# Output
OUT_CSV = DATA_DIR + "/iq_sq_gr_average.csv"
OUT_PLOT = DATA_DIR + "/iq_sq_gr_plot.png"


# ============================================================
# Helper: safe logging that does not break tqdm bar
# ============================================================

def info(msg: str):
    """Print a message without breaking tqdm progress bar."""
    tqdm.write(msg)


# ============================================================
# Utilities
# ============================================================

def random_unit_vectors(n, rng):
    """Generate n random unit vectors uniformly on the sphere."""
    z = rng.uniform(-1.0, 1.0, size=n)
    phi = rng.uniform(0.0, 2.0 * np.pi, size=n)
    r_xy = np.sqrt(np.clip(1.0 - z*z, 0.0, None))
    x = r_xy * np.cos(phi)
    y = r_xy * np.sin(phi)
    return np.column_stack([x, y, z])


def load_configuration(path):
    """Load x,y,z,nx,ny,nz from CSV and return positions, normals."""
    data = np.loadtxt(path, delimiter=",", skiprows=1)
    positions = data[:, :3]
    normals = data[:, 3:]
    normals /= (np.linalg.norm(normals, axis=1, keepdims=True) + 1e-12)
    return positions, normals


def disc_amplitude(normals, q_vec,
                   R=RADIUS, T=THICKNESS, dr=DELTA_RHO):
    """
    Cylinder (disc) scattering amplitude for each particle:

      F = Δρ [2 sin(q_par T/2)/q_par] [2πR J1(q_perp R)/q_perp]

    normals : (N,3)
    q_vec   : (3,)
    returns : (N,) complex128 (real here, but complex type)
    """
    q2 = np.dot(q_vec, q_vec)

    q_par = normals @ q_vec           # (N,)
    q_perp_sq = np.clip(q2 - q_par**2, 0.0, None)
    q_perp = np.sqrt(q_perp_sq)
    arg = q_perp * R

    eps = 1e-12

    # z-factor
    zfac = np.where(
        np.abs(q_par) < eps,
        T,
        2.0 * np.sin(q_par * T / 2.0) / q_par
    )

    # r-factor
    rfac = np.where(
        np.abs(arg) < eps,
        np.pi * R**2,
        2.0 * np.pi * R * j1(arg) / (q_perp + eps)
    )

    F = dr * zfac * rfac
    return F.astype(np.complex128)


# ============================================================
# g(r) calculation
# ============================================================

def compute_gr(positions, r_max=GR_RMAX, n_bins=GR_NBINS):
    """
    Compute radial distribution function g(r) using a simple histogram.
    positions : (N,3)

    Returns:
      r_centers : (n_bins,)
      g_r       : (n_bins,)
    """
    N = positions.shape[0]
    dists = []

    # pair distances i<j
    for i in range(N):
        dif = positions[i+1:] - positions[i]
        rij = np.linalg.norm(dif, axis=1)
        dists.append(rij)

    if len(dists) == 0:
        # N<2
        r_centers = np.linspace(0, r_max, n_bins, endpoint=False)
        return r_centers, np.ones_like(r_centers)

    d = np.concatenate(dists)
    bins = np.linspace(0.0, r_max, n_bins+1)
    hist, edges = np.histogram(d, bins=bins)

    r_centers = 0.5 * (edges[:-1] + edges[1:])
    dr = edges[1] - edges[0]

    # box volume (rough estimate from bounding box)
    Lx = np.max(positions[:, 0]) - np.min(positions[:, 0])
    # assume cubic box (this matches how we typically generated them)
    box_vol = Lx**3
    rho = N / (box_vol + 1e-12)

    shell_vol = 4.0 * np.pi * r_centers**2 * dr
    ideal_counts = rho * shell_vol * N

    g_r = hist / (ideal_counts + 1e-12)
    return r_centers, g_r


# ============================================================
# I(q), S(q) for a single configuration
# ============================================================

def compute_iq_sq(positions,
                  normals,
                  q_values,
                  n_dirs=N_Q_DIRECTIONS,
                  rng=None,
                  pbar=None):
    """
    Compute I(q) and S(q) for one configuration.

    I(q): full disc amplitude with orientation.
    S(q): center-of-mass structure factor.

    pbar: tqdm progress bar; if provided, updated once per q.
    """
    if rng is None:
        rng = np.random.default_rng()

    Nq = q_values.size
    Np = positions.shape[0]

    Iq = np.zeros(Nq, dtype=float)
    Sq = np.zeros(Nq, dtype=float)

    # random directions shared across q
    q_dirs = random_unit_vectors(n_dirs, rng)  # (n_dirs,3)

    for iq, q in enumerate(q_values):
        I_sum = 0.0
        S_sum = 0.0

        for d in range(n_dirs):
            q_vec = q * q_dirs[d]
            phase = positions @ q_vec                 # (N,)

            # COM contribution
            A_com = np.exp(1j * phase).sum()

            # disc amplitude per particle
            F_j = disc_amplitude(normals, q_vec)      # (N,)
            A_full = (F_j * np.exp(1j * phase)).sum()

            I_sum += (A_full.conjugate() * A_full).real
            S_sum += (A_com.conjugate() * A_com).real / Np

        Iq[iq] = I_sum / n_dirs
        Sq[iq] = S_sum / n_dirs

        if pbar is not None:
            pbar.update(1)

    return Iq, Sq


# ============================================================
# Main
# ============================================================

def main():
    # find config files
    pattern = os.path.join(DATA_DIR, FILE_PATTERN)
    paths = sorted(glob.glob(pattern))

    if not paths:
        print(f"[ERROR] No configuration files found at {pattern}")
        return

    print("[INFO] Found configuration files:")
    for p in paths:
        print("   ", p)

    # q-grid
    if LOG_Q:
        q_values = np.logspace(np.log10(Q_MIN), np.log10(Q_MAX), N_Q)
    else:
        q_values = np.linspace(Q_MIN, Q_MAX, N_Q)

    print(f"[INFO] q-grid: {N_Q} points from {q_values[0]:.4e} to {q_values[-1]:.4e} nm^-1")
    print(f"[INFO] Using {N_Q_DIRECTIONS} random directions per q")

    total_steps = len(paths) * len(q_values)
    pbar = tqdm(total=total_steps, desc="Total progress", leave=True)

    rng = np.random.default_rng(RNG_SEED)

    all_Iq = []
    all_Sq = []
    all_gr = []
    rgrid_ref = None

    for idx, path in enumerate(paths):
        info(f"[INFO] Processing config {idx+1}/{len(paths)}: {os.path.basename(path)}")
        positions, normals = load_configuration(path)

        Iq, Sq = compute_iq_sq(
            positions,
            normals,
            q_values,
            n_dirs=N_Q_DIRECTIONS,
            rng=rng,
            pbar=pbar
        )
        all_Iq.append(Iq)
        all_Sq.append(Sq)

        rgrid, gr = compute_gr(positions)
        all_gr.append(gr)
        if rgrid_ref is None:
            rgrid_ref = rgrid

    pbar.close()

    # average
    Iq_mean = np.mean(all_Iq, axis=0)
    Sq_mean = np.mean(all_Sq, axis=0)
    gr_mean = np.mean(all_gr, axis=0)

    # save CSV (I and S)
    out = np.column_stack([q_values, Iq_mean, Sq_mean])
    header = "q,Iq,Sq"
    np.savetxt(OUT_CSV, out, delimiter=",", header=header, comments="")
    print(f"[INFO] Saved {OUT_CSV}")

    # plotting
    fig, axes = plt.subplots(3, 1, figsize=(7, 11))

    # I(q)
    axes[0].loglog(q_values, Iq_mean / (Iq_mean.max() + 1e-12), label="I(q)")
    axes[0].set_xlabel("q (nm$^{-1}$)")
    axes[0].set_ylabel("I(q) (normalized)")
    axes[0].set_title("I(q) (disc model)")
    axes[0].grid(True, which="both", ls=":")
    axes[0].legend()

    # S(q)
    axes[1].loglog(q_values, Sq_mean / (Sq_mean.max() + 1e-12),
                   label="S(q)", color="orange")
    axes[1].set_xlabel("q (nm$^{-1}$)")
    axes[1].set_ylabel("S(q) (normalized)")
    axes[1].set_title("S(q) (COM only)")
    axes[1].grid(True, which="both", ls=":")
    axes[1].legend()

    # g(r)
    if rgrid_ref is not None:
        axes[2].plot(rgrid_ref, gr_mean, "-k")
        axes[2].set_xlabel("r (nm)")
        axes[2].set_ylabel("g(r)")
        axes[2].set_title("Radial Distribution Function g(r)")
        axes[2].grid(True, ls=":")

    plt.tight_layout()
    plt.savefig(OUT_PLOT, dpi=200)
    plt.close()
    print(f"[INFO] Saved plot to {OUT_PLOT}")
    print("[INFO] Done.")


if __name__ == "__main__":
    main()
